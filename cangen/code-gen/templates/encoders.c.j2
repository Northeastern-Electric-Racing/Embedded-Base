{#
    This is a Jinja template, everything in {{ }} or {% %} brackets is replaced with C code.
    Code inside brackets are Python snippets.

    Note: dont use tabs in C code, replace them with four spaces (tabs cause weird formatting issues). 

    This file creates the encoder functions given a list of CANMsg obejcts.
-#}


{% import "templates/macros.j2" as macros -%}

{{ macros.imports() -}}
#include "can_handler.h"

{% for msg in can_msgs -%}
void send_{{ macros.function_name(msg) }}
(
    {% for field in msg.fields -%}
    {% for value in field["values"] -%}
    {{ macros.field_type(msg.points, field) }} {{ macros.field_name(field, loop.index) }},
    {% endfor -%}
    {% endfor -%}
    can_t *can
)
{
    {% set field_idx = namespace(value=0) -%}
    bitstream_t {{ macros.function_name(msg) }}_msg;
	uint8_t bitstream_data[{{ macros.msg_size(msg) }}];
	bitstream_init(&{{ macros.function_name(msg) }}_msg, bitstream_data, {{ macros.msg_size(msg) }});

	{% for field in msg.fields -%}
    {% for value in field["values"] -%}
        {% set point = msg.points[value - 1] -%}
        {% if point.parse is not defined or point.parse == true -%}
        bitstream_add(&{{ macros.function_name(msg) -}}_msg, {{ macros.field_name(field, loop.index) -}}, {{ point.size -}});
    {% set field_idx.value = field_idx.value + 1 -%}
    {% endif -%}
    {% endfor -%}
    {%- endfor %}
    can_msg_t msg;
    msg.id = {{ msg.id }};
    msg.len = sizeof(bitstream_data);
    memcpy(msg.data, &bitstream_data, sizeof(bitstream_data));

    queue_can_msg(msg);
}

{% endfor %}